using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using GrpcServer;

namespace TypeDBCustom
{ 
    public class CoreClient
    {

        // this session id will be assigned when session opened and used in every transaction
        private Google.Protobuf.ByteString sessionID = null;
        // this will hold the response for session pulse 
        static Session.Types.Pulse.Types.Res pulseResp = null;
        // this will be pulse request object that will be passed to client for session pulse
        static Session.Types.Pulse.Types.Req pulseRequest = null;
        // this timer will be used to automatically send pulse message every 5 seconds 
        private readonly Timer tPulse = new Timer((obj) => pulseResp = Client.session_pulse(pulseRequest), null, Timeout.Infinite, Timeout.Infinite);

        // this will be used to pass the transaction requesst to bi-directional stream
        public readonly Transaction.Types.Client transactionClient = new Transaction.Types.Client();        
        // this is the main object that will be used for all kind of transaction, e.g queries, insert, define, update, match
        private Grpc.Core.AsyncDuplexStreamingCall<Transaction.Types.Client, Transaction.Types.Server> transactions = null;
        // this will be used to hold the current transaction ressponse in the bi-directional stream
        private static Transaction.Types.Server transResp = null;

        // this will reference the host and port to typeDB protocol client
        private Grpc.Core.Channel grpcChannel = null;
        // this is the TypeDBClient which is generated by protocol
        public static TypeDB.TypeDBClient Client = null;
         
        public Grpc.Core.AsyncDuplexStreamingCall<Transaction.Types.Client, Transaction.Types.Server> Transactions {
            get { return transactions; } 
        }
        public Google.Protobuf.ByteString SessionID
        {
            get { return sessionID; }
        }


        /// <summary>
        /// Initialize the object and connects to remote TypeDB server using gRPC
        /// </summary>
        /// <param name="host">hostname or IP for TypeDB server</param>
        /// <param name="port">port for TypeDB server</param>
        public CoreClient(string host, int port)
        {
            grpcChannel = new Grpc.Core.Channel(host, port, Grpc.Core.ChannelCredentials.Insecure);
            Client = new TypeDB.TypeDBClient(grpcChannel);
        }

        /// <summary>
        /// This will get all the available databases on TypeDB server
        /// </summary>
        /// <returns>All the available database names on TypeDB server</returns>
        public string[] GetAllDatabases()
        {
            var databases = Client.databases_all(new CoreDatabaseManager.Types.All.Types.Req() { });
            return databases.Names.ToArray<string>();
        }

        /// <summary>
        /// This will create the database for you in TypeDB server
        /// </summary>
        /// <param name="DatabaseName"></param>
        public void CreateDatabase(string DatabaseName)
        {
            //create the databse in the server
            Client.databases_create(new CoreDatabaseManager.Types.Create.Types.Req() { Name = DatabaseName });
        }

        /// <summary>
        /// this method will open the session with server for specific database
        /// if the connection successfull it will start pulse automatically.
        /// It will make the transaction open request here as well.
        /// </summary>
        /// <param name="DatabaseName">The name of the database you want to link</param>
        public void OpenDatabase(string DatabaseName, Session.Types.Type sessionType = Session.Types.Type.Data)
        {

            //creates new session request and pass the database name session type as parameters. it will open new session for TypeDB server
            Session.Types.Open.Types.Res session = Client.session_open(new Session.Types.Open.Types.Req()
            {
                Database = DatabaseName,
                Type = sessionType                
            }, null, null, CancellationToken.None);
            sessionID = session.SessionId;
            // fills the session id to pulse request so it can be used in session_pulse command
            pulseRequest = new Session.Types.Pulse.Types.Req() { SessionId = session.SessionId };
            // starts the timer with 5 seconds interval
            tPulse.Change(0, 5000);

            // creates the bi-directional stream for transactions
            transactions = Client.transaction(null, null, CancellationToken.None);            

            // fill the sessionId in transaction open request. it will open the stream for communication.
            trans_open.OpenReq.SessionId = session.SessionId;
            trans_open.ReqId = session.SessionId;
            // add the transaction open request to transaction client.
            transactionClient.Reqs.Add(trans_open);
            // use the transaction client to write the transaction on stream
            transactions.RequestStream.WriteAsync(transactionClient).GetAwaiter().GetResult();
            // move the read to next element so server response will be clear from open transaction resp
            transactions.ResponseStream.MoveNext(CancellationToken.None).GetAwaiter().GetResult();
            transResp = transactions.ResponseStream.Current;

        }

        /// <summary>
        /// this will disable the session pulse interval and closes the session for database
        /// </summary>
        public void CloseDatabase()
        {
            // changing this to infinite will stop the timer and clear the interval
            tPulse.Change(Timeout.Infinite, Timeout.Infinite);
            // create the session close request and pass it to client object with session ID
            Client.session_close(new Session.Types.Close.Types.Req()
            {
                SessionId = pulseRequest.SessionId
            });
        }

        /// <summary>
        /// If the bi-directional stream still have pending data it will message in CONTINUE, 
        /// in that case the will be passed the transaction client and write to stream so we can have rest of data
        /// if the stream response DONE instead of CONTINUE then we don't need to use this.
        /// </summary>
        public static Transaction.Types.Req trans_stream = new Transaction.Types.Req()
        {
            StreamReq = new Transaction.Types.Stream.Types.Req() { }
        };

        // this will be used for transaction open request for bi-directional stream
        private static readonly Transaction.Types.Req trans_open = new Transaction.Types.Req() 
        {
            OpenReq = new Transaction.Types.Open.Types.Req()
            {
                SessionId = Google.Protobuf.ByteString.CopyFromUtf8("req_open"),
                Type = Transaction.Types.Type.Read,                
                Options = new Options() { Infer = true}
            }            
        };

        // this is for test purposes
        private static QueryManager.Types.Req query = new QueryManager.Types.Req()
        {
            MatchReq = new QueryManager.Types.Match.Types.Req()
            {
                //Query = "match $x isa person; offset 0; limit 30;"
                //Query = "match $tra isa travel; get $tra;"
                Query = "match $tra (traveler: $per) isa travel; (located: $tra, location: $loc) isa localisation; $loc has name \"French Lick\"; $per has full-name $fn; get $fn;"
            },
            Options = new Options() { Parallel = true}
        };

    }
}
